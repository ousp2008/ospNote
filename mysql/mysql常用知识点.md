# mysql

## 一.mysql的安装及可视化工具 

数据库的的下载地址：[下载地址](https://dev.mysql.com/downloads/)   安装教程可参考 [安装教程](https://www.cnblogs.com/solargen/p/6835399.html) 

安装完后可在命令控制行cmd中输入：mysql -uroot -p 查看安装的版本信息，如果出现版本信息则安装成功

数据库安装后，我们只能通过命令行对数据库进行操作，很不方便，可以通过可视化工具进行操作

可视化工具在windows一般使用Navicat for mysql 或者 sqlyog，这里我列出的事  sqlyog 可参考：[sqlyog下载及安装参考](https://blog.csdn.net/lihua5419/article/details/73881837/)  

安装完后，我们就可以正常的操作数据库了。

# 二.mysql基础

## 数据库的三范式：

第一范式（1NF）：

数据表中的每一列(字段)，必须是不可拆分的最小单元，也就是确保每一列的原子性。

例如： userInfo: '山东省烟台市 1318162008' 依照第一范式必须拆分成

userInfo: '山东省烟台市' userTel: '1318162008'两个字段

第二范式（2NF）：

满足1NF后要求表中的所有列，都必需依赖于主键，而不能有 任何一列与主键没有关系（一个表只描述一件事情）。

例如：订单表只能描述订单相关的信息，所以所有的字段都必须与订单ID相关。

产品表只能描述产品相关的信息，所以所有的字段都必须与产品ID相关。

因此在同一张表中不能同时出现订单信息与产品信息。

第三范式（3NF）：第三范式(3NF)：满足2NF后，要求：表中的每一列都要与主键直接相关，而不是间接相关（表中的每一列只能依赖于主键）

例如：订单表中需要有客户相关信息，在分离出客户表之后，订单表中只需要有一个用户

ID即可，而不能有其他的客户信息，因为其他的用户信息是直接关联于用户ID，而不是关联

## 数据库的五大约束：

1.主键约束（Primay Key Coustraint） 唯一性，非空性；

2.唯一约束 （Unique Counstraint）唯一性，可以空，但只能有一个；

3.默认约束 (Default Counstraint) 该数据的默认值；

4.外键约束 (Foreign Key Counstraint) 需要建立两表间的关系；

5.非空约束（ Not Null Counstraint ）:设置非空约束，该字段不能为空。

## 数据库调优

### 基本原则

​	避免全表扫描

​	建立索引

## 创建索引

索引的目的是 提高查询效率 避免全表查询

创建索引语句：

```sql
CREATE TABLE table_name[col_name data type][unique|fulltext][index|key][index_name](col_name[length])[asc|desc]
```

1.unique|fulltext为可选参数，分别表示唯一索引、全文索引
2.index和key为同义词，两者作用相同，用来指定创建索引
3.col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择
4.index_name指定索引的名称，为可选参数，如果不指定，默认col_name为索引值
5.length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度
6.asc或desc指定升序或降序的索引值存储

（4）删除索引

```sql
DROP INDEX index_name ON table
```

### 索引类型：

1.普通索引

​	是最基本的索引，它没有任何限制。它有以下几种创建方式：
（1）直接创建索引

```sql
CREATE INDEX index_name ON table(column(length))
```

（2）修改表结构的方式添加索引

```sql
ALTER TABLE table_name ADD INDEX index_name ON (column(length))
```

（3）创建表的时候同时创建索引

```sql
CREATE TABLE `table` (
    `id` int(11) NOT NULL AUTO_INCREMENT ,
    `title` char(255) CHARACTER NOT NULL ,
    `content` text CHARACTER NULL ,
    `time` int(10) NULL DEFAULT NULL ,    PRIMARY KEY (`id`),    INDEX index_name (title(length))
)
```

2.唯一索引

​	与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组	合必须唯一。它有以下几种创建方式：

​	（1）创建唯一索引

```sql
CREATE UNIQUE INDEX indexName ON table(column(length))
```

（2）修改表结构

```sql
ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))
```

3.主键索引

​	是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引：

```sql
CREATE TABLE `table` (
    `id` int(11) NOT NULL AUTO_INCREMENT ,
    `title` char(255) NOT NULL ,    PRIMARY KEY (`id`)
);
```

4.联合索引 [可参考](https://blog.csdn.net/wdjxxl/article/details/79790421)

​	最左前缀原理（左边的出现有效，后面的才会有效） 如：我们在（a,b,c）字段上建了一个联合索引，所以这个索引是先按a 再按b 再按c进行排列的

​	下面是可以用索引的where，where可乱序:

```sql
select * from table where a=1；
select * from table where a=1 and b=2；
select * from table where a=1 and b=2 and c=3；

```

下面用到的where 只会用到部分索引或者用不到索引：

```sql 
select * from table where a=1 and c=3； 那么只会用到索引a。
select * from table where b=2 and c=3； 因为没有用到最左前缀a，所以这个查询是用户到索引的。

```

总结：索引的最左原则（左前缀原则），如（c1,c2,c3,c4....cN）的联合索引，where 条件按照索引建立的字段顺序来使用（不代表and条件必须按照顺序来写），如果中间某列没有条件，或使用like会导致后面的列不能使用索引。

5.全文索引

### 索引的数据结构

B+Tree

B+树是B-Tree的变形树

B-Tree树的特性：

> 1） 根结点的孩子数>=2(前提是树高度大于1)
> 2） 除根结点与叶子结点，其他结点的孩子数为[ceil(m/2),m]个。ceil函数表示上取整数
> 3） 所有叶子结点都出现在同一层，叶子结点不存储数据。
> 4） 各个结点包含n个关键字信息：(P0,K1,P1,K2,P2......Kn,Pn)
>  其中：
>    4.1) Ki(i=1,2......n)为关键字，且K(i-1)<Ki，即从小到大排序
>    4.2) 关键字的个数n必须满足：[ceil(m/2)-1,m-1]
>    4.3) Pi指向子树，且指针P(i-1)所指向的子树结点中所有关键字均小于Ki。即：父结点中任何关键字的左孩子都小于它，右孩子大于它。

B+tree和B-Tree的差异：

> ```
> 1） 非叶子结点的子树指针与关键字个数相同；
> 2） B+树父结点中的记录，存储的是下层子树中的最小值；
> 3） 所有叶子结点通过一个链指针相连；
> 4） 所有关键字都在叶子结点出现；
> 
> ```

### sql语句调优

 使用慢查询日志，找出执行慢的查询

​	show valiables like 'general%'

​	其中general_log:日志记录功能是否开启，默认是OFF，我们需要设置为ON ；set GLOBAL general_log='ON'

​	然后再次查询是否开启

使用explain select来决定查询功能是否合适

使用show profile 以及show profiles语句可以显示当前会话过程中执行sql语句的性能信息

主要查看 type的值和extra的值如果type的值出现了index和all一般都是需要优化的，key值是看用到的索引

通过pt工具和慢查询日志的配合，可以轻松地分辨出全表扫描的语句

使用mysqldumpslow命令可以非常明确的得到各种我们需要的查询语句，对MySQL查询语句的监控、分析、优化是MySQL优化的第一步，也是非常重要的一步。



#### 对于where 字句后条件 的调优

1：在where、group by he order by 的列上加索引 ，如果合适，用group by代替distinct

2: 避免在where字句中使用 != 或 <> 操作符 否则引擎会放弃使用索引

3：避免在where字句中使用 or 来连接条件,可以考虑使用union 代替

4：避免在 where 子句中对字段进行表达式操作和函数操作

5：in 和 not in 也要慎用，对于连续的数值，能用 between 就不要用 in，exists 代替 in

6:一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而**like “aaa%”**可以使用索引。

#### 对于字段的调优：

1：varchar/nvarchar 代替 char/nchar ，因为变长字段存储空间小，对于查询来说，在一个相对较小的字段内搜索效率显然要高些

2:最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。 因为列中 包含有null都不会使用索引

3:查询时不要select * 而要用具体的字段代替*不要返回用不到的任何字段。

#### 关于临时表

避免频繁创建和删除临时表，以减少系统表资源的消耗。对于一次性事件， 最好使用导出表。

在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

如果使用到了临时表，在最后将所有的临时表显式删除时，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。

### 数据库架构调优

- 分区分表
- 业务分库
- 主从同步与读写分离
- 数据缓存
- 主从热备与HA双活

## 存储引擎 MyISAM和InnoDB区别

MyISAM 是非事务的存储引擎；锁的级别是：表锁。不支持外键；支持全文索引；支持直接拷贝表到另一台服务器；是堆表

innodb是支持事务的存储引擎；锁的级别是：行锁。支持外键；不支持直接拷贝表到另一台服务器；索引组织表

最大的区别就是MYISAM适合小数据，小并发或频繁查询的应用；INNODB 适合大数据，大并发或插入和更新操作比较多的应用

## myslq查询语句的执行顺序

开始->FROM子句->WHERE子句->GROUP BY子句->HAVING子句->ORDER BY子句->SELECT子句->LIMIT子句->最终结果 

每个子句执行后都会产生一个中间结果，供接下来的子句使用，如果不存在某个子句，就跳过 

## mysql面试之事务

### 事务的五个特征：

1. 原子性（Atomicity）：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚
2. 一致性（Consistency）：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性
3. 隔离性（Isolation）：操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。
4. 持久性：事务一旦提交，其结果就是永久的。即便发生系统故障，也能恢复。

### 事务不隔离带来的影响

1. 更新丢失：两事务同时更新，一个失败回滚覆盖另一个事务的更新。或事务1执行更细操作，在事务1结束前事务2也更新，则事务1的更细结果被事务2的覆盖了。
2. 脏读：事务T2读取到事务T1修改了但是还未提交的数据，之后事务T1又回滚其更新操作，导致事务T2读到的是脏数据。
3. 不可重复读：事务T1读取某个数据后，事务T2对其做了修改，当事务T1再次读该数据时得到与前一次不同的值。
4. 虚读（幻读）：事务T1读取在读取某范围数据时，事务T2又插入一条数据，当事务T1再次数据这个范围数据时发现不一样了，出现了一些“幻影行”。

### 事务的隔离级别 可参考文章 [事务隔离级别](https://mp.weixin.qq.com/s?src=11&timestamp=1552283797&ver=1477&signature=80P7L-fmBMFj08Hk4xdtj9pgR7C3NfX84OrkQZc6ahzB9WPXdYp8LbOfX9ayhFHKD5L9OMkqz8Y74btmYcDHUPrtOlP9nlk0t1B9jNtBF14YGwkL-CmQXyhR3NQ3yOY6&new=1) 

1. 未提交读

   事务的最低隔离级别，在这种隔离级别下，一个事务可以读取另外一个事务未提交的数据。

   **数据库锁实现原理：**

   **事务T在读数据的时候并未对数据进行加锁，事务T在修改数据的时候对数据增加行级共享锁**

   T1在读取数据时，T2可以对相同数据进行读取、修改。因为T1没有进行任何锁操作；当T2对记录进行修改时，T1再次读取数据可以读取到T2修改后的数据。因为T2对数据进行修改只增加了行级共享锁，T1可以再增加共享读锁进行数据读取（尽管T2没有提交事务）

   如上所述，这种隔离级别，会导致脏读现象



2. 已提交读

   在一个事务修改数据过程中，如果事务没有进行提交，其他事务不能读取该数据

   数据库锁实现原理:

   **事务T在读取数据时增加行级共享锁，读取一旦结束，立即释放；事务T在修改数据时增加行级排他锁，直到事务结束才释放。**

   T1在读取数据的过程中，T2也可以对相同数据进行读取，但是不能进行修改（T1增加的是共享锁，T2也可以增加共享锁，但是不能增加排他锁）。T1读取结束后，会立即释放共享锁，这时T2可以增加排他锁，对数据进行修改，而此时T1既不能对数据进行读取也不能进行修改，直到T2事务结束。

   如上所述，这种隔离级别，解决了脏读问题，但是不能解决不可重复读现象。



3. 可重复读  （mysql默认的级别）

   **事务T在数据读取时，必须增加行级共享锁，直到事务结束；事务T在修改数据过程中，必须增加行级排他锁，直到数据结束。**

   **数据库锁实现原理：**

   T1在读取数据的过程中，T2也可以对相同数据进行读取，但是不能进行修改（T1增加的是共享锁，T2也可以增加共享锁，但是不能增加排他锁）。直到T1事务结束后，才会释放共享锁，这时T2才可以增加排他锁，对数据进行修改。

   如上所述，这种隔离级别，解决了不可重复读现象，但是这种隔离级别解决不了幻读的问题：

   T1进行查询，读取了10条记录，并对十条记录增加了行级锁，此时T2是无法对这10行数据进行修改操作的，但是由于没有表级锁，它可以增加一条满足T1查询条件的记录。随后T1在进行查询时，会发现虽然10条记录没有改变，但是突然多了一条记录。

4. 序列化

   产生幻读是由于没有进行范围查询时没有增加范围锁。

   **数据库锁实现原理：**

    **事务T在读取数据时，必须先增加表级共享锁，直到事务结束才释放；事务T在修改数据时，必须先增加表级排他锁，直到事务结束才释放。**

   T1在读取A表时，增加了表级共享锁，此时T2也可以读取A表，但是不能进行任何数据的修改，直到T1事务结束。随后T2可以增加对A表的表级排他锁，此时T1不能读取A表中的任何数据，更不能进行修改。

   如上所述，可序列化解决了脏读、不可重复读、幻读等读现象，但是隔离级别越来越高的同时，在并发性上也就越来越低。

四种事务隔离解决的问题：

![1552285320244](./assets/1552285320244.png)

## MVCC 可参照 文章[ 参考](https://mp.weixin.qq.com/s?src=11&timestamp=1552286772&ver=1477&signature=5EuWx9yzvSi18dR8-eyWnlqTtYqYPQ84S1Ad3n9AiHQixYPy2Ior2-bbqBdCsZNFnb4tWwfUs2uV63MRqD6EFmQODk4*e4xVoWPGZfhRTjahiMbrcJY0g52mIe9M0ldK&new=1)

什么事mvcc:**Multiversion Concurrency Control**多版本并发控制

用来避免写操作堵塞读操作的并发问题，MVCC也就是通过使用数据的多个版本保证并发读写不冲突的一种机制，不同的数据库有不同的实现，这也是数据库系统让人头疼的地方.

第一种实现方式是将数据记录的多个版本保存在数据库中，当这些不同版本数据不再需要时，垃圾收集器回收这些记录。这个方式被PostgreSQL和Firebird/Interbase采用，SQL Server使用的类似机制，所不同的是旧版本数据不是保存在数据库中，而保存在不同于主数据库的另外一个数据库tempdb中/

第二种实现方式只在数据库保存最新版本的数据，但是会在使用undo时动态重构旧版本数据，这种方式被Oracle和MySQL/InnoDB使用。

可用于解决幻读

事务的隔离级别：读提交和可重复读

特点是：不管执行多长时间，事物前后的数据一致，同一时间同一表，不同事务看到的结果可能不同

它的实现是因为 根据两个版本，即两个时间，通过添加两个隐藏的属性（**DB_TRX_ID**和**DB_ROLL_PT**）创建时间以及删除时间，默认递增

在查询 insert时：为当前的行创建新建版本

在删除 delete是：为当前行插入删除版本 （执行完上述SQL之后数据并没有被真正删除，而是对删除版本号做改变）

在修改时：1.为原来行创建删除版本 2.为新的行创建新建版本

在查询select时：【检查】（通过才返回结果）1.查找创建版本小于或等于当前事务版本的创建版本行2.查找**删除版本号**要么为NULL，要么**大于当前事务版本号**的记录

如：

books表中有5条数据，此时mysql给它设定的版本号为1。

这个时候有两个事务性的操作，事务A,B

**事务A**  系统版本号2：select * from books；因为1<=2所以此时会读取5条数据。

**事务B**  系统版本号3：insert into books ...，插入一条数据，新插入的数据版本号为3，而其他的数据的版本号仍然是2，插入完成之后commit，事务结束。

**事务A**  系统版本号2：再次select * from books；只能读取<=2的数据，事务B新插入的那条数据版本号为3，因此读不出来，解决了幻读的问题。

## 锁

死锁：主要是事物之间由于隔离级别最高，开启行锁，易造成相互持有对方的锁 [可参考](https://www.cnblogs.com/LBSer/p/5183300.html)

悲观锁：通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。[ 可参考](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)

乐观锁:一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，类似CAS

## 事务日志

数据故障恢复

实现：

事务日志是通过redo和innodb的存储引擎日志缓冲(Innodb log buffer)来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志。当事务提交时，必须将存储引擎的日志缓冲写入磁盘(通过innodb_flush_log_at_trx_commit来控制)，也就是写数据前，需要先写日志。这种方式称为“预写日志方式”

​	
